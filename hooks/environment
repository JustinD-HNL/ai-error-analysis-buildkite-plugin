#!/bin/bash
set -euo pipefail

# AI Error Analysis Buildkite Plugin - Environment Hook
# This hook runs before checkout and sets up the environment for error analysis

# Plugin directory
PLUGIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Source utility functions
source "${PLUGIN_DIR}/lib/utils.sh" 2>/dev/null || {
  echo "Warning: Could not load utility functions"
}

# Initialize logging
LOG_PREFIX="ü§ñ [AI Error Analysis]"

echo "--- ${LOG_PREFIX} Setting up environment"

# Validate Python 3 availability
if ! command -v python3 &> /dev/null; then
  echo "‚ùå Python 3 is required but not found. Please install Python 3.7 or later."
  exit 1
fi

# Check Python version (minimum 3.7)
PYTHON_VERSION=$(python3 -c "import sys; print('.'.join(map(str, sys.version_info[:2])))")
if ! python3 -c "import sys; sys.exit(0 if sys.version_info >= (3, 7) else 1)"; then
  echo "‚ùå Python ${PYTHON_VERSION} found, but Python 3.7 or later is required."
  exit 1
fi

echo "‚úÖ Python ${PYTHON_VERSION} detected"

# Validate required commands
REQUIRED_COMMANDS=("curl" "jq")
for cmd in "${REQUIRED_COMMANDS[@]}"; do
  if ! command -v "$cmd" &> /dev/null; then
    echo "‚ùå Required command '$cmd' not found. Please install it."
    exit 1
  fi
done

# Set up plugin environment variables with defaults
export AI_ERROR_ANALYSIS_PLUGIN_DIR="${PLUGIN_DIR}"

# Security: Enable agent security features
export BUILDKITE_NO_COMMAND_EVAL="${BUILDKITE_NO_COMMAND_EVAL:-true}"
export BUILDKITE_NO_LOCAL_HOOKS="${BUILDKITE_NO_LOCAL_HOOKS:-true}"

# Configuration validation and normalization
echo "--- ${LOG_PREFIX} Validating configuration"

# Input validation configuration
validate_input_configuration() {
  local max_log_size="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_INPUT_VALIDATION_MAX_LOG_SIZE_MB:-50}"
  local validation_enabled="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_INPUT_VALIDATION_ENABLED:-true}"
  
  if [[ "${validation_enabled}" == "true" ]]; then
    echo "‚úÖ Input validation enabled (max log size: ${max_log_size}MB)"
    
    # Validate numeric values
    if ! [[ "${max_log_size}" =~ ^[0-9]+$ ]] || [[ "${max_log_size}" -lt 1 ]] || [[ "${max_log_size}" -gt 200 ]]; then
      echo "‚ùå Invalid max_log_size_mb: ${max_log_size}. Must be between 1 and 200."
      exit 1
    fi
    
    export AI_ERROR_ANALYSIS_MAX_LOG_SIZE_BYTES=$((max_log_size * 1024 * 1024))
  fi
}

validate_input_configuration

# Enhanced AI Providers validation with secret management
AI_PROVIDERS="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_AI_PROVIDERS:-[{\"name\":\"openai\",\"model\":\"gpt-4o-mini\"}]}"
echo "Configured AI providers: ${AI_PROVIDERS}"

# Validate AI provider configuration and secret access
validate_ai_providers_and_secrets() {
  local providers="$1"
  
  # Create temporary Python script for validation
  local temp_script=$(mktemp)
  cat > "${temp_script}" << 'EOF'
import json
import os
import sys
import subprocess

def get_secret_aws(secret_name, region='us-east-1'):
    """Retrieve secret from AWS Secrets Manager"""
    try:
        import boto3
        from botocore.exceptions import ClientError, NoCredentialsError
        session = boto3.session.Session()
        client = session.client('secretsmanager', region_name=region)
        response = client.get_secret_value(SecretId=secret_name)
        secret_data = json.loads(response['SecretString'])
        return secret_data.get('api_key') or secret_data.get('value') or response['SecretString']
    except (ClientError, NoCredentialsError) as e:
        print(f'‚ùå AWS Secrets Manager error for {secret_name}: {e}')
        return None
    except ImportError:
        print(f'‚ö†Ô∏è boto3 not available for AWS Secrets Manager')
        return None
    except Exception as e:
        print(f'‚ùå Error retrieving AWS secret {secret_name}: {e}')
        return None

def get_secret_vault(vault_path):
    """Retrieve secret from HashiCorp Vault"""
    try:
        result = subprocess.run(
            ['vault', 'kv', 'get', '-format=json', vault_path],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            vault_data = json.loads(result.stdout)
            return vault_data.get('data', {}).get('data', {}).get('api_key') or vault_data.get('data', {}).get('data', {}).get('value')
        else:
            print(f'‚ùå Vault error for {vault_path}: {result.stderr}')
            return None
    except subprocess.TimeoutExpired:
        print(f'‚ùå Vault timeout for {vault_path}')
        return None
    except Exception as e:
        print(f'‚ùå Error retrieving Vault secret {vault_path}: {e}')
        return None

def get_secret_gcp(secret_name):
    """Retrieve secret from GCP Secret Manager"""
    try:
        result = subprocess.run(
            ['gcloud', 'secrets', 'versions', 'access', 'latest', '--secret', secret_name, '--format=get(payload.data)', '--decode'],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            return result.stdout.strip()
        else:
            print(f'‚ùå GCP Secret Manager error for {secret_name}: {result.stderr}')
            return None
    except subprocess.TimeoutExpired:
        print(f'‚ùå GCP Secret Manager timeout for {secret_name}')
        return None
    except Exception as e:
        print(f'‚ùå Error retrieving GCP secret {secret_name}: {e}')
        return None

def validate_model_name(provider, model):
    """Validate that model name is supported"""
    valid_models = {
        'openai': ['gpt-4.1', 'gpt-4o', 'gpt-4o-mini', 'o4-mini', 'gpt-3.5-turbo'],
        'claude': ['claude-opus-4', 'claude-sonnet-4', 'claude-3-opus-20240229', 'claude-3-sonnet-20240229', 'claude-3-haiku-20240307'],
        'gemini': ['gemini-2.5-pro', 'gemini-2.5-flash', 'gemini-1.5-pro', 'gemini-1.5-flash']
    }
    
    return model in valid_models.get(provider, [])

def main():
    try:
        providers_json = sys.argv[1] if len(sys.argv) > 1 else '[]'
        providers = json.loads(providers_json)
        if not isinstance(providers, list):
            providers = [providers]
        
        missing_secrets = []
        invalid_models = []
        secret_access_errors = []
        
        for provider in providers:
            name = provider.get('name', '').lower()
            model = provider.get('model', '')
            secret_source = provider.get('secret_source', {})
            
            # Validate model name
            if not validate_model_name(name, model):
                invalid_models.append(f'{name}: {model}')
            
            # Handle secret management
            secret_type = secret_source.get('type', 'env_var')
            secret_value = None
            
            if secret_type == 'aws_secrets_manager':
                secret_name = secret_source.get('name')
                region = secret_source.get('region', 'us-east-1')
                if secret_name:
                    secret_value = get_secret_aws(secret_name, region)
                else:
                    missing_secrets.append(f'{name}: missing secret_source.name for AWS Secrets Manager')
            
            elif secret_type == 'vault':
                vault_path = secret_source.get('vault_path')
                if vault_path:
                    secret_value = get_secret_vault(vault_path)
                else:
                    missing_secrets.append(f'{name}: missing secret_source.vault_path for Vault')
            
            elif secret_type == 'gcp_secret_manager':
                secret_name = secret_source.get('name')
                if secret_name:
                    secret_value = get_secret_gcp(secret_name)
                else:
                    missing_secrets.append(f'{name}: missing secret_source.name for GCP Secret Manager')
            
            elif secret_type == 'env_var':
                # Fallback to environment variable
                api_key_env = secret_source.get('name', f'{name.upper()}_API_KEY')
                secret_value = os.environ.get(api_key_env)
                if not secret_value:
                    missing_secrets.append(f'{name}: {api_key_env} (environment variable)')
            
            else:
                missing_secrets.append(f'{name}: unknown secret_source.type: {secret_type}')
            
            # Validate secret was retrieved
            if secret_value is None and secret_type != 'env_var':
                secret_access_errors.append(f'{name}: failed to retrieve secret via {secret_type}')
        
        # Report validation results
        if invalid_models:
            print('‚ùå Invalid AI models detected:')
            for model in invalid_models:
                print(f'  - {model}')
            print('Please use supported 2025 model names.')
            sys.exit(1)
        
        if missing_secrets:
            print('‚ùå Missing or inaccessible API secrets:')
            for secret in missing_secrets:
                print(f'  - {secret}')
            print('Please configure external secret management or set environment variables.')
            sys.exit(1)
        
        if secret_access_errors:
            print('‚ö†Ô∏è Secret access warnings:')
            for error in secret_access_errors:
                print(f'  - {error}')
            # Don't fail on warnings, just log them
        
        if not missing_secrets and not invalid_models:
            print('‚úÖ All AI providers and secrets validated successfully')
            
    except json.JSONDecodeError as e:
        print(f'‚ùå Invalid AI providers configuration JSON: {e}')
        sys.exit(1)
    except ImportError as e:
        print(f'‚ö†Ô∏è Optional dependency missing: {e}')
        print('Some secret management features may be unavailable.')
        print('‚úÖ Proceeding with environment variable fallback')
    except Exception as e:
        print(f'‚ùå Error validating AI providers: {e}')
        sys.exit(1)

if __name__ == "__main__":
    main()
EOF

  # Execute the Python script with the providers configuration
  python3 "${temp_script}" "${providers}"
  local exit_code=$?
  
  # Clean up temporary script
  rm -f "${temp_script}"
  
  return $exit_code
}

# Only validate secrets if not in dry run mode
DRY_RUN="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_DRY_RUN:-false}"
if [[ "${DRY_RUN}" != "true" ]]; then
  validate_ai_providers_and_secrets "${AI_PROVIDERS}"
else
  echo "üß™ Dry run mode enabled - skipping secret validation"
fi

# Container security validation
validate_container_security() {
  local run_as_non_root="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_SECURITY_CONTAINER_SECURITY_RUN_AS_NON_ROOT:-true}"
  local drop_capabilities="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_SECURITY_CONTAINER_SECURITY_DROP_CAPABILITIES:-[\"ALL\"]}"
  local no_new_privileges="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_SECURITY_CONTAINER_SECURITY_NO_NEW_PRIVILEGES:-true}"
  
  if [[ "${run_as_non_root}" == "true" ]]; then
    echo "‚úÖ Container security: non-root execution enabled"
    export AI_ERROR_ANALYSIS_CONTAINER_USER="1000:1000"
  fi
  
  if [[ "${no_new_privileges}" == "true" ]]; then
    echo "‚úÖ Container security: no-new-privileges enabled"
    export AI_ERROR_ANALYSIS_SECURITY_OPTS="--security-opt=no-new-privileges:true"
  fi
  
  echo "‚úÖ Container security: capability dropping configured"
  export AI_ERROR_ANALYSIS_CAP_DROP="${drop_capabilities}"
}

validate_container_security

# Set up secure redaction patterns
setup_redaction_patterns() {
  # Enhanced built-in sensitive patterns (2025 update)
  REDACTION_PATTERNS=(
    # Modern API keys and tokens
    "(?i)(api[_-]?key|apikey|token|secret|password|passwd|pwd)[\s]*[=:]+[\s]*['\"]?([^\\s'\"]{8,})['\"]?"
    # Bearer tokens
    "Bearer[\s]+[a-zA-Z0-9._-]{20,}"
    # JWT tokens
    "eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*"
    # Modern OAuth tokens
    "(?i)(access[_-]?token|refresh[_-]?token)[\s]*[=:]+[\s]*['\"]?([^\\s'\"]{20,})['\"]?"
    # Cloud provider patterns
    "AKIA[0-9A-Z]{16}"  # AWS Access Key
    "(?i)aws[_-]?secret[_-]?access[_-]?key[\s]*[=:]+[\s]*['\"]?([^\\s'\"]{40})['\"]?"
    # Container registry tokens
    "(?i)(docker[_-]?|registry[_-]?)(token|password)[\s]*[=:]+[\s]*['\"]?([^\\s'\"]{20,})['\"]?"
    # Database connection strings
    "(?i)(mongodb|postgresql|mysql|redis)://[^\\s@]+:[^\\s@]+@[^\\s/]+[^\\s]*"
    # SSH private keys
    "-----BEGIN[\\s\\w]*PRIVATE[\\s\\w]*KEY-----[\\s\\S]*?-----END[\\s\\w]*PRIVATE[\\s\\w]*KEY-----"
    # URLs with credentials
    "https?://[^:]+:[^@]+@[^\\s]+"
    # Certificate data
    "-----BEGIN CERTIFICATE-----[\\s\\S]*?-----END CERTIFICATE-----"
    # Modern webhook URLs with tokens
    "https://hooks\\.slack\\.com/services/[A-Z0-9]{9}/[A-Z0-9]{9}/[a-zA-Z0-9]{24}"
  )
  
  # Add custom patterns from configuration
  CUSTOM_PATTERNS="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_REDACTION_CUSTOM_PATTERNS:-[]}"
  if [[ "${CUSTOM_PATTERNS}" != "[]" ]]; then
    echo "Adding custom redaction patterns: ${CUSTOM_PATTERNS}"
  fi
  
  # Export for use in other hooks
  export AI_ERROR_ANALYSIS_REDACTION_PATTERNS="$(printf '%s\n' "${REDACTION_PATTERNS[@]}")"
}

setup_redaction_patterns

# Command validation setup
setup_command_validation() {
  local validation_enabled="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_SECURITY_ENABLE_COMMAND_VALIDATION:-true}"
  local allowed_commands="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_INPUT_VALIDATION_ALLOWED_COMMANDS:-[]}"
  
  if [[ "${validation_enabled}" == "true" ]]; then
    echo "‚úÖ Command injection prevention enabled"
    export AI_ERROR_ANALYSIS_COMMAND_VALIDATION="true"
    
    # Set up allowed commands list
    if [[ "${allowed_commands}" != "[]" ]]; then
      echo "Command whitelist configured: ${allowed_commands}"
      export AI_ERROR_ANALYSIS_ALLOWED_COMMANDS="${allowed_commands}"
    fi
  fi
}

setup_command_validation

# Repository and branch validation with enhanced security
validate_repository_access() {
  local repo="${BUILDKITE_REPO:-}"
  local branch="${BUILDKITE_BRANCH:-}"
  local allowed_branches="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_CONDITIONS_BRANCHES:-[]}"
  
  # Validate repository URL format to prevent injection
  if [[ -n "${repo}" ]]; then
    if [[ ! "${repo}" =~ ^(git@|https://)[a-zA-Z0-9._/-]+$ ]]; then
      echo "‚ùå Invalid repository URL format: ${repo}"
      exit 1
    fi
  fi
  
  # Validate branch name to prevent injection
  if [[ -n "${branch}" ]]; then
    if [[ ! "${branch}" =~ ^[a-zA-Z0-9._/-]+$ ]]; then
      echo "‚ùå Invalid branch name format: ${branch}"
      exit 1
    fi
  fi
  
  # Skip validation if no branch restrictions
  if [[ "${allowed_branches}" == "[]" ]]; then
    echo "‚úÖ No branch restrictions configured"
    return 0
  fi
  
  # Check if current branch is allowed
  local temp_script=$(mktemp)
  cat > "${temp_script}" << 'EOF'
import json
import sys

def main():
    try:
        allowed_json = sys.argv[1] if len(sys.argv) > 1 else '[]'
        current_branch = sys.argv[2] if len(sys.argv) > 2 else ''
        
        allowed = json.loads(allowed_json)
        
        if not allowed or current_branch in allowed:
            print(f'‚úÖ Branch "{current_branch}" is allowed for AI analysis')
        else:
            print(f'‚ÑπÔ∏è Branch "{current_branch}" not in allowed list: {allowed}')
            print('Skipping AI error analysis for this branch')
            # Set flag to skip analysis but don't fail the build
            sys.exit(42)  # Special exit code to indicate skip
            
    except json.JSONDecodeError as e:
        print(f'‚ùå Invalid branch configuration JSON: {e}')
        sys.exit(1)
    except Exception as e:
        print(f'‚ùå Error validating branch: {e}')
        sys.exit(1)

if __name__ == "__main__":
    main()
EOF
  
  python3 "${temp_script}" "${allowed_branches}" "${branch}"
  local exit_code=$?
  
  # Clean up temporary script
  rm -f "${temp_script}"
  
  if [[ $exit_code -eq 42 ]]; then
    export AI_ERROR_ANALYSIS_SKIP="true"
    return 0
  elif [[ $exit_code -ne 0 ]]; then
    echo "‚ùå Repository validation failed"
    return 1
  fi
}

validate_repository_access

# Set up secure caching with proper permissions
setup_caching() {
  local cache_enabled="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_PERFORMANCE_CACHE_ENABLED:-true}"
  local cache_dir="${BUILDKITE_BUILD_PATH}/.ai-error-analysis-cache"
  
  if [[ "${cache_enabled}" == "true" ]]; then
    mkdir -p "${cache_dir}"
    
    # Set secure permissions (owner only)
    chmod 700 "${cache_dir}"
    
    export AI_ERROR_ANALYSIS_CACHE_DIR="${cache_dir}"
    echo "‚úÖ Secure caching enabled at ${cache_dir}"
  else
    echo "‚ÑπÔ∏è Caching disabled"
  fi
}

setup_caching

# Install Python dependencies securely
install_dependencies() {
  local lib_dir="${PLUGIN_DIR}/lib"
  
  # Check if required libraries are available
  local temp_script=$(mktemp)
  cat > "${temp_script}" << 'EOF'
import sys
missing_deps = []

try:
    import requests
except ImportError:
    missing_deps.append('requests')

try:
    import boto3
except ImportError:
    print('‚ÑπÔ∏è boto3 not available - AWS Secrets Manager disabled')

if missing_deps:
    print('üì¶ Installing required Python packages...')
    print(f'Missing: {missing_deps}')
    sys.exit(1)
else:
    print('‚úÖ Python dependencies satisfied')
EOF

  if ! python3 "${temp_script}"; then
    echo "üì¶ Installing required Python packages..."
    
    # Install with user flag for security
    python3 -m pip install --user --no-cache-dir requests || {
      echo "‚ùå Failed to install Python dependencies"
      echo "Please ensure 'requests' library is available: pip install requests"
      exit 1
    }
    
    # Optional dependencies for secret management
    python3 -m pip install --user --no-cache-dir boto3 2>/dev/null || {
      echo "‚ÑπÔ∏è boto3 not installed - AWS Secrets Manager will be unavailable"
    }
  fi
  
  # Clean up temporary script
  rm -f "${temp_script}"
}

install_dependencies

# Set up signal handlers for cleanup
setup_signal_handlers() {
  # Create cleanup function
  cleanup() {
    local exit_code=$?
    echo "--- ${LOG_PREFIX} Cleaning up environment setup"
    
    # Remove any temporary files created during setup
    if [[ -n "${AI_ERROR_ANALYSIS_TEMP_DIR:-}" ]] && [[ -d "${AI_ERROR_ANALYSIS_TEMP_DIR}" ]]; then
      rm -rf "${AI_ERROR_ANALYSIS_TEMP_DIR}"
    fi
    
    # Clear any temporary environment variables with secrets
    unset AI_ERROR_ANALYSIS_TEMP_SECRET 2>/dev/null || true
    
    exit $exit_code
  }
  
  # Register cleanup on script exit
  trap cleanup EXIT
}

setup_signal_handlers

# Rate limiting setup
setup_rate_limiting() {
  local requests_per_minute="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_RATE_LIMIT_REQUESTS_PER_MINUTE:-30}"
  local burst_limit="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_RATE_LIMIT_BURST_LIMIT:-10}"
  
  # Validate rate limiting values
  if ! [[ "${requests_per_minute}" =~ ^[0-9]+$ ]] || [[ "${requests_per_minute}" -lt 1 ]] || [[ "${requests_per_minute}" -gt 100 ]]; then
    echo "‚ùå Invalid requests_per_minute: ${requests_per_minute}. Must be between 1 and 100."
    exit 1
  fi
  
  if ! [[ "${burst_limit}" =~ ^[0-9]+$ ]] || [[ "${burst_limit}" -lt 1 ]] || [[ "${burst_limit}" -gt 50 ]]; then
    echo "‚ùå Invalid burst_limit: ${burst_limit}. Must be between 1 and 50."
    exit 1
  fi
  
  export AI_ERROR_ANALYSIS_RATE_LIMIT_RPM="${requests_per_minute}"
  export AI_ERROR_ANALYSIS_RATE_LIMIT_BURST="${burst_limit}"
  
  echo "‚úÖ Rate limiting configured: ${requests_per_minute} req/min, ${burst_limit} burst"
}

setup_rate_limiting

# Debug information (if debug mode enabled)
DEBUG_MODE="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_DEBUG_MODE:-false}"
if [[ "${DEBUG_MODE}" == "true" ]]; then
  echo "--- ${LOG_PREFIX} Debug Information"
  echo "Plugin directory: ${PLUGIN_DIR}"
  echo "Python version: $(python3 --version)"
  echo "Current user: $(whoami)"
  echo "Working directory: $(pwd)"
  echo "Available disk space: $(df -h . | tail -1 | awk '{print $4}')"
  echo "Memory usage: $(free -h | grep '^Mem:' | awk '{print $3 "/" $2}' || echo 'N/A')"
  echo "Container security enabled: ${AI_ERROR_ANALYSIS_CONTAINER_USER:-disabled}"
  echo "Command validation enabled: ${AI_ERROR_ANALYSIS_COMMAND_VALIDATION:-disabled}"
  
  # Show relevant environment variables (redacted)
  echo "Environment variables:"
  env | grep -E "^(BUILDKITE_|AI_ERROR_ANALYSIS_)" | sed 's/\(.*=\).*/\1[REDACTED]/' | sort
fi

# Export configuration for other hooks
export AI_ERROR_ANALYSIS_INITIALIZED="true"
export AI_ERROR_ANALYSIS_LOG_PREFIX="${LOG_PREFIX}"

echo "‚úÖ ${LOG_PREFIX} Environment setup complete"

# Enhanced health check with security validation
echo "--- ${LOG_PREFIX} Running security-enhanced health check"
if python3 "${PLUGIN_DIR}/lib/health_check.py"; then
  echo "‚úÖ Health check passed"
else
  echo "‚ùå Health check failed"
  exit 1
fi