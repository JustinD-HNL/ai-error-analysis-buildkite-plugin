#!/bin/bash
set -euo pipefail

# AI Error Analysis Buildkite Plugin - Environment Hook (2025 Update)
# Enhanced security with external secret management support

# Plugin directory
PLUGIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Initialize logging
LOG_PREFIX="ü§ñ [AI Error Analysis]"

echo "--- ${LOG_PREFIX} Setting up environment"

# Validate Python 3.10+ (2025 requirement)
if ! command -v python3 &> /dev/null; then
  echo "‚ùå Python 3 is required but not found. Please install Python 3.10 or later."
  exit 1
fi

# Check Python version (minimum 3.10)
PYTHON_VERSION=$(python3 -c "import sys; print('.'.join(map(str, sys.version_info[:2])))")
if ! python3 -c "import sys; sys.exit(0 if sys.version_info >= (3, 10) else 1)"; then
  echo "‚ùå Python ${PYTHON_VERSION} found, but Python 3.10 or later is required (3.9 EOL October 2025)."
  exit 1
fi

echo "‚úÖ Python ${PYTHON_VERSION} detected"

# Validate required commands
REQUIRED_COMMANDS=("curl" "jq")
for cmd in "${REQUIRED_COMMANDS[@]}"; do
  if ! command -v "$cmd" &> /dev/null; then
    echo "‚ùå Required command '$cmd' not found. Please install it."
    exit 1
  fi
done

# Set up plugin environment variables
export AI_ERROR_ANALYSIS_PLUGIN_DIR="${PLUGIN_DIR}"

# Security: Enable additional protections
export BUILDKITE_NO_COMMAND_EVAL="${BUILDKITE_NO_COMMAND_EVAL:-true}"

echo "--- ${LOG_PREFIX} Validating configuration and secrets"

# External secret management validation
validate_external_secrets() {
  local use_external_secrets="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_SECURITY_EXTERNAL_SECRETS_ENABLED:-false}"
  
  if [[ "${use_external_secrets}" == "true" ]]; then
    local provider="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_SECURITY_EXTERNAL_SECRETS_PROVIDER:-}"
    
    echo "üîê External secret management enabled: ${provider}"
    
    case "${provider}" in
      "aws-secrets-manager")
        validate_aws_secrets_manager
        ;;
      "hashicorp-vault")
        validate_vault
        ;;
      "gcp-secret-manager")
        validate_gcp_secret_manager
        ;;
      *)
        echo "‚ùå Invalid external secrets provider: ${provider}"
        echo "Valid providers: aws-secrets-manager, hashicorp-vault, gcp-secret-manager"
        exit 1
        ;;
    esac
  else
    echo "‚ÑπÔ∏è Using environment variables for API keys (less secure)"
    validate_environment_variables
  fi
}

validate_aws_secrets_manager() {
  echo "üîê Validating AWS Secrets Manager configuration..."
  
  # Check AWS CLI availability
  if ! command -v aws &> /dev/null; then
    echo "‚ùå AWS CLI not found. Please install AWS CLI for Secrets Manager support."
    exit 1
  fi
  
  # Check AWS credentials
  if ! aws sts get-caller-identity &> /dev/null; then
    echo "‚ùå AWS credentials not configured or invalid."
    echo "Please configure AWS credentials using IAM roles, instance profiles, or environment variables."
    exit 1
  fi
  
  # Validate region
  local region="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_SECURITY_EXTERNAL_SECRETS_REGION:-us-east-1}"
  echo "‚úÖ AWS Secrets Manager configured (region: ${region})"
  
  # Test secret access (if secret path is provided)
  local secret_path="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_SECURITY_EXTERNAL_SECRETS_SECRET_PATH:-}"
  if [[ -n "${secret_path}" ]]; then
    if aws secretsmanager describe-secret --secret-id "${secret_path}" --region "${region}" &> /dev/null; then
      echo "‚úÖ Secret accessible: ${secret_path}"
    else
      echo "‚ùå Cannot access secret: ${secret_path}"
      echo "Please ensure the secret exists and IAM permissions are correct."
      exit 1
    fi
  fi
}

validate_vault() {
  echo "üîê Validating HashiCorp Vault configuration..."
  
  # Check Vault CLI availability
  if ! command -v vault &> /dev/null; then
    echo "‚ùå Vault CLI not found. Please install Vault CLI."
    exit 1
  fi
  
  # Check Vault environment variables
  if [[ -z "${VAULT_ADDR:-}" ]]; then
    echo "‚ùå VAULT_ADDR environment variable not set."
    exit 1
  fi
  
  if [[ -z "${VAULT_TOKEN:-}" ]]; then
    echo "‚ùå VAULT_TOKEN environment variable not set."
    exit 1
  fi
  
  # Test Vault connectivity
  if ! vault auth -method=token &> /dev/null; then
    echo "‚ùå Cannot authenticate with Vault server."
    echo "Please check VAULT_ADDR and VAULT_TOKEN."
    exit 1
  fi
  
  echo "‚úÖ Vault connectivity verified"
  
  # Test secret access (if secret path is provided)
  local secret_path="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_SECURITY_EXTERNAL_SECRETS_SECRET_PATH:-}"
  if [[ -n "${secret_path}" ]]; then
    if vault kv get "${secret_path}" &> /dev/null; then
      echo "‚úÖ Secret accessible: ${secret_path}"
    else
      echo "‚ùå Cannot access secret: ${secret_path}"
      echo "Please ensure the secret exists and Vault permissions are correct."
      exit 1
    fi
  fi
}

validate_gcp_secret_manager() {
  echo "üîê Validating Google Secret Manager configuration..."
  
  # Check gcloud CLI availability
  if ! command -v gcloud &> /dev/null; then
    echo "‚ùå gcloud CLI not found. Please install Google Cloud SDK."
    exit 1
  fi
  
  # Check authentication
  if ! gcloud auth list --filter=status:ACTIVE --format="value(account)" &> /dev/null; then
    echo "‚ùå Google Cloud not authenticated."
    echo "Please run: gcloud auth login"
    exit 1
  fi
  
  # Check project
  local project_id="${GOOGLE_CLOUD_PROJECT:-}"
  if [[ -z "${project_id}" ]]; then
    project_id=$(gcloud config get-value project 2>/dev/null)
    if [[ -z "${project_id}" ]]; then
      echo "‚ùå Google Cloud project not set."
      echo "Please set GOOGLE_CLOUD_PROJECT or run: gcloud config set project PROJECT_ID"
      exit 1
    fi
  fi
  
  echo "‚úÖ Google Secret Manager configured (project: ${project_id})"
  
  # Test secret access (if secret path is provided)
  local secret_path="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_SECURITY_EXTERNAL_SECRETS_SECRET_PATH:-}"
  if [[ -n "${secret_path}" ]]; then
    if gcloud secrets describe "${secret_path}" --project="${project_id}" &> /dev/null; then
      echo "‚úÖ Secret accessible: ${secret_path}"
    else
      echo "‚ùå Cannot access secret: ${secret_path}"
      echo "Please ensure the secret exists and IAM permissions are correct."
      exit 1
    fi
  fi
}

validate_environment_variables() {
  echo "üîê Validating environment variable API keys..."
  
  # Get AI providers configuration
  local providers_config="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_AI_PROVIDERS:-[{\"name\":\"openai\",\"model\":\"gpt-4o-mini\"}]}"
  
  # Validate JSON
  if ! echo "${providers_config}" | jq empty 2>/dev/null; then
    echo "‚ùå Invalid AI providers configuration JSON"
    exit 1
  fi
  
  # Check each provider's API key
  local missing_keys=()
  
  # Use Python to parse JSON and check API keys
  python3 << PYTHON_SCRIPT
import json
import os
import sys

try:
    providers = json.loads('${providers_config}')
    if not isinstance(providers, list):
        providers = [providers]
    
    missing_keys = []
    
    for provider in providers:
        name = provider.get('name', '').lower()
        api_key_env = provider.get('api_key_env', f'{name.upper()}_API_KEY')
        
        if not os.environ.get(api_key_env):
            missing_keys.append(f'{name}: {api_key_env}')
    
    if missing_keys:
        print('‚ùå Missing API keys:')
        for key in missing_keys:
            print(f'  - {key}')
        print('Please set the required environment variables.')
        sys.exit(1)
    else:
        print('‚úÖ All required API keys found')
        
except json.JSONDecodeError as e:
    print(f'‚ùå Invalid AI providers configuration: {e}')
    sys.exit(1)
except Exception as e:
    print(f'‚ùå Error validating API keys: {e}')
    sys.exit(1)
PYTHON_SCRIPT
}

# AI Providers validation with 2025 model names
validate_ai_providers() {
  local providers_config="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_AI_PROVIDERS:-[{\"name\":\"openai\",\"model\":\"gpt-4o-mini\"}]}"
  
  echo "ü§ñ Validating AI provider configurations..."
  
  # Validate using Python with correct 2025 model names
  python3 << PYTHON_SCRIPT
import json
import sys

try:
    providers = json.loads('${providers_config}')
    if not isinstance(providers, list):
        providers = [providers]
    
    # 2025 Valid models
    valid_models = {
        'openai': ['gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo', 'gpt-3.5-turbo', 'o1-preview', 'o1-mini'],
        'anthropic': ['claude-3-5-haiku-20241022', 'claude-3-5-sonnet-20241022', 'claude-3-opus-20240229', 'claude-3-sonnet-20240229', 'claude-3-haiku-20240307'],
        'gemini': ['gemini-2.0-flash-exp', 'gemini-1.5-pro', 'gemini-1.5-flash', 'gemini-1.5-flash-8b']
    }
    
    invalid_models = []
    
    for provider in providers:
        name = provider.get('name', '').lower()
        model = provider.get('model', '')
        
        if name not in valid_models:
            invalid_models.append(f'{name}: unknown provider')
        elif model not in valid_models[name]:
            invalid_models.append(f'{name}: {model} (valid: {", ".join(valid_models[name][:3])}...)')
    
    if invalid_models:
        print('‚ùå Invalid AI provider/model configurations:')
        for model in invalid_models:
            print(f'  - {model}')
        print('Please use supported 2025 model names.')
        sys.exit(1)
    else:
        print('‚úÖ All AI provider configurations valid')
        
except json.JSONDecodeError as e:
    print(f'‚ùå Invalid AI providers JSON: {e}')
    sys.exit(1)
except Exception as e:
    print(f'‚ùå Error validating providers: {e}')
    sys.exit(1)
PYTHON_SCRIPT
}

# Repository and branch validation
validate_repository_access() {
  local repo="${BUILDKITE_REPO:-}"
  local branch="${BUILDKITE_BRANCH:-}"
  local allowed_branches="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_CONDITIONS_BRANCHES:-[]}"
  
  # Security: Validate repository URL format
  if [[ -n "${repo}" ]]; then
    if [[ ! "${repo}" =~ ^(git@|https://)[a-zA-Z0-9._/-]+$ ]]; then
      echo "‚ùå Invalid repository URL format: ${repo}"
      exit 1
    fi
  fi
  
  # Security: Validate branch name
  if [[ -n "${branch}" ]]; then
    if [[ ! "${branch}" =~ ^[a-zA-Z0-9._/-]+$ ]]; then
      echo "‚ùå Invalid branch name format: ${branch}"
      exit 1
    fi
  fi
  
  # Skip validation if no branch restrictions
  if [[ "${allowed_branches}" == "[]" ]]; then
    echo "‚úÖ No branch restrictions configured"
    return 0
  fi
  
  # Branch validation using Python
  python3 << PYTHON_SCRIPT
import json
import sys

try:
    allowed = json.loads('${allowed_branches}')
    current_branch = '${branch}'
    
    if not allowed or current_branch in allowed:
        print(f'‚úÖ Branch "{current_branch}" is allowed for AI analysis')
        sys.exit(0)
    else:
        print(f'‚ÑπÔ∏è Branch "{current_branch}" not in allowed list: {allowed}')
        print('Skipping AI error analysis for this branch')
        # Set flag to skip analysis
        with open('/tmp/ai-error-analysis-skip', 'w') as f:
            f.write('true')
        sys.exit(0)
        
except json.JSONDecodeError as e:
    print(f'‚ùå Invalid branch configuration: {e}')
    sys.exit(1)
PYTHON_SCRIPT
  
  # Check if we should skip analysis
  if [[ -f "/tmp/ai-error-analysis-skip" ]]; then
    export AI_ERROR_ANALYSIS_SKIP="true"
    rm -f "/tmp/ai-error-analysis-skip"
  fi
}

# Container security validation (if running in container)
validate_container_security() {
  local enforce_non_root="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_CONTAINER_SECURITY_ENFORCE_NON_ROOT:-true}"
  
  if [[ "${enforce_non_root}" == "true" ]]; then
    if [[ "$(id -u)" -eq 0 ]]; then
      echo "‚ùå Security violation: Running as root user is not allowed"
      echo "Please configure the plugin to run as a non-root user"
      exit 1
    fi
    echo "‚úÖ Container security: Running as non-root user ($(id -u))"
  fi
  
  # Check for security features if available
  if [[ -f "/proc/self/status" ]]; then
    if grep -q "NoNewPrivs:\s*1" /proc/self/status 2>/dev/null; then
      echo "‚úÖ Container security: NoNewPrivs enabled"
    else
      echo "‚ö†Ô∏è Warning: NoNewPrivs not enabled"
    fi
  fi
}

# Set up secure caching
setup_caching() {
  local cache_enabled="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_PERFORMANCE_CACHE_ENABLED:-true}"
  local cache_dir="${BUILDKITE_BUILD_PATH}/.ai-error-analysis-cache"
  
  if [[ "${cache_enabled}" == "true" ]]; then
    mkdir -p "${cache_dir}"
    chmod 700 "${cache_dir}"  # Secure permissions
    export AI_ERROR_ANALYSIS_CACHE_DIR="${cache_dir}"
    echo "‚úÖ Secure caching enabled at ${cache_dir}"
  else
    echo "‚ÑπÔ∏è Caching disabled"
  fi
}

# Install Python dependencies with security considerations
install_dependencies() {
  echo "üì¶ Installing Python dependencies..."
  
  # Create requirements.txt with 2025 versions
  cat > /tmp/requirements.txt << 'EOF'
openai>=1.30.0
anthropic>=0.25.0
google-generativeai>=0.5.0
requests>=2.31.0
pyyaml>=6.0.1
cryptography>=41.0.0
boto3>=1.28.0
google-cloud-secret-manager>=2.16.0
EOF
  
  # Install dependencies securely
  if ! python3 -m pip install --user --no-cache-dir --requirement /tmp/requirements.txt 2>/dev/null; then
    echo "‚ö†Ô∏è Some optional dependencies failed to install"
    echo "Installing minimal required dependencies..."
    
    # Fallback to essential packages only
    python3 -m pip install --user --no-cache-dir requests || {
      echo "‚ùå Failed to install essential Python dependencies"
      exit 1
    }
  fi
  
  # Clean up
  rm -f /tmp/requirements.txt
  
  echo "‚úÖ Python dependencies installed"
}

# Rate limiting setup
setup_rate_limiting() {
  local requests_per_minute="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_PERFORMANCE_RATE_LIMIT_REQUESTS_PER_MINUTE:-20}"
  local burst_limit="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_PERFORMANCE_RATE_LIMIT_BURST_LIMIT:-5}"
  
  # Validate rate limiting values
  if ! [[ "${requests_per_minute}" =~ ^[0-9]+$ ]] || [[ "${requests_per_minute}" -lt 1 ]] || [[ "${requests_per_minute}" -gt 100 ]]; then
    echo "‚ùå Invalid requests_per_minute: ${requests_per_minute}. Must be between 1 and 100."
    exit 1
  fi
  
  export AI_ERROR_ANALYSIS_RATE_LIMIT_RPM="${requests_per_minute}"
  export AI_ERROR_ANALYSIS_RATE_LIMIT_BURST="${burst_limit}"
  
  echo "‚úÖ Rate limiting configured: ${requests_per_minute} req/min, ${burst_limit} burst"
}

# Enhanced redaction patterns setup
setup_enhanced_redaction() {
  echo "üßπ Setting up enhanced log sanitization..."
  
  # Enhanced built-in patterns for 2025
  REDACTION_PATTERNS=(
    # Modern API keys and tokens
    "sk-[a-zA-Z0-9]{48}"  # OpenAI keys
    "sk-ant-api03-[a-zA-Z0-9_-]{95}"  # Anthropic keys
    "AIza[a-zA-Z0-9_-]{35}"  # Google API keys
    "Bearer[\\s]+[a-zA-Z0-9._-]{20,}"  # Bearer tokens
    "eyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*"  # JWT tokens
    "AKIA[0-9A-Z]{16}"  # AWS Access Keys
    "gh[pousr]_[A-Za-z0-9_]{36,}"  # GitHub tokens
    "https://hooks\\.slack\\.com/services/[A-Z0-9]{9}/[A-Z0-9]{9}/[a-zA-Z0-9]{24}"  # Slack webhooks
  )
  
  export AI_ERROR_ANALYSIS_REDACTION_PATTERNS="$(printf '%s\\n' "${REDACTION_PATTERNS[@]}")"
  echo "‚úÖ Enhanced redaction patterns configured"
}

# Main execution flow
main() {
  # Core validations
  validate_ai_providers
  validate_external_secrets
  validate_repository_access
  
  # Security setup
  validate_container_security
  setup_enhanced_redaction
  
  # Performance setup
  setup_caching
  setup_rate_limiting
  
  # Dependencies
  install_dependencies
  
  # Export configuration
  export AI_ERROR_ANALYSIS_INITIALIZED="true"
  export AI_ERROR_ANALYSIS_LOG_PREFIX="${LOG_PREFIX}"
  
  echo "‚úÖ ${LOG_PREFIX} Environment setup complete"
}

# Enhanced debug information
DEBUG_MODE="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_DEBUG_MODE:-false}"
if [[ "${DEBUG_MODE}" == "true" ]]; then
  echo "--- ${LOG_PREFIX} Debug Information"
  echo "Plugin directory: ${PLUGIN_DIR}"
  echo "Python version: $(python3 --version)"
  echo "Current user: $(whoami) (UID: $(id -u))"
  echo "Working directory: $(pwd)"
  echo "Available disk space: $(df -h . | tail -1 | awk '{print $4}' 2>/dev/null || echo 'N/A')"
  echo "Memory usage: $(free -h 2>/dev/null | grep '^Mem:' | awk '{print $3 "/" $2}' || echo 'N/A')"
  
  # Show sanitized environment variables
  echo "Environment variables (sanitized):"
  env | grep -E "^(BUILDKITE_|AI_ERROR_ANALYSIS_)" | sed 's/\(.*=\).*/\1[REDACTED]/' | sort
fi

# Execute main setup
main

# Final health check
echo "--- ${LOG_PREFIX} Running health check"
if python3 "${PLUGIN_DIR}/lib/health_check.py" 2>/dev/null; then
  echo "‚úÖ Health check passed"
else
  echo "‚ùå Health check failed"
  exit 1
fi