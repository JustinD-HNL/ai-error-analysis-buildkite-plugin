#!/bin/bash
set -euo pipefail

# AI Error Analysis Buildkite Plugin - Environment Hook
# This hook runs before checkout and sets up the environment for error analysis

# Plugin directory
PLUGIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Source utility functions
source "${PLUGIN_DIR}/lib/utils.sh" 2>/dev/null || {
  echo "Warning: Could not load utility functions"
}

# Initialize logging
LOG_PREFIX="ü§ñ [AI Error Analysis]"

echo "--- ${LOG_PREFIX} Setting up environment"

# Validate Python 3 availability
if ! command -v python3 &> /dev/null; then
  echo "‚ùå Python 3 is required but not found. Please install Python 3.7 or later."
  exit 1
fi

# Check Python version (minimum 3.7)
PYTHON_VERSION=$(python3 -c "import sys; print('.'.join(map(str, sys.version_info[:2])))")
if ! python3 -c "import sys; sys.exit(0 if sys.version_info >= (3, 7) else 1)"; then
  echo "‚ùå Python ${PYTHON_VERSION} found, but Python 3.7 or later is required."
  exit 1
fi

echo "‚úÖ Python ${PYTHON_VERSION} detected"

# Validate required commands
REQUIRED_COMMANDS=("curl" "jq")
for cmd in "${REQUIRED_COMMANDS[@]}"; do
  if ! command -v "$cmd" &> /dev/null; then
    echo "‚ùå Required command '$cmd' not found. Please install it."
    exit 1
  fi
done

# Set up plugin environment variables with defaults
export AI_ERROR_ANALYSIS_PLUGIN_DIR="${PLUGIN_DIR}"

# Configuration validation and normalization
echo "--- ${LOG_PREFIX} Validating configuration"

# AI Providers validation
AI_PROVIDERS="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_AI_PROVIDERS:-[{\"name\":\"openai\",\"model\":\"gpt-4o-mini\"}]}"
echo "Configured AI providers: ${AI_PROVIDERS}"

# Validate AI provider API keys
validate_ai_providers() {
  local providers="$1"
  
  # Parse providers using Python (more reliable than bash JSON parsing)
  python3 -c "
import json
import os
import sys

try:
    providers = json.loads('${AI_PROVIDERS}')
    if not isinstance(providers, list):
        providers = [providers]
    
    missing_keys = []
    for provider in providers:
        name = provider.get('name', '').lower()
        api_key_env = provider.get('api_key_env', f'{name.upper()}_API_KEY')
        
        if api_key_env not in os.environ:
            missing_keys.append(f'{name}: {api_key_env}')
    
    if missing_keys:
        print('‚ùå Missing API keys for providers:')
        for key in missing_keys:
            print(f'  - {key}')
        print('Please set the required environment variables.')
        sys.exit(1)
    else:
        print('‚úÖ All required API keys found')
        
except json.JSONDecodeError as e:
    print(f'‚ùå Invalid AI providers configuration: {e}')
    sys.exit(1)
except Exception as e:
    print(f'‚ùå Error validating AI providers: {e}')
    sys.exit(1)
"
}

# Only validate API keys if not in dry run mode
DRY_RUN="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_DRY_RUN:-false}"
if [[ "${DRY_RUN}" != "true" ]]; then
  validate_ai_providers "${AI_PROVIDERS}"
else
  echo "üß™ Dry run mode enabled - skipping API key validation"
fi

# Set up secure redaction patterns
setup_redaction_patterns() {
  # Built-in sensitive patterns
  REDACTION_PATTERNS=(
    # Secrets and tokens
    "(?i)(password|passwd|pwd|secret|token|key|auth)[\s]*[=:]+[\s]*['\"]?([^\\s'\"]+)"
    # API keys
    "(?i)(api[_-]?key|apikey)[\s]*[=:]+[\s]*['\"]?([^\\s'\"]+)"
    # URLs with credentials
    "https?://[^:]+:[^@]+@[^\\s]+"
    # SSH keys
    "-----BEGIN[\\s\\w]*PRIVATE[\\s\\w]*KEY-----[\\s\\S]*?-----END[\\s\\w]*PRIVATE[\\s\\w]*KEY-----"
    # Email addresses (optional - might be useful context)
    # "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"
  )
  
  # Add custom patterns from configuration
  CUSTOM_PATTERNS="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_REDACTION_CUSTOM_PATTERNS:-[]}"
  if [[ "${CUSTOM_PATTERNS}" != "[]" ]]; then
    echo "Adding custom redaction patterns: ${CUSTOM_PATTERNS}"
  fi
  
  # Export for use in other hooks
  export AI_ERROR_ANALYSIS_REDACTION_PATTERNS="$(printf '%s\n' "${REDACTION_PATTERNS[@]}")"
}

setup_redaction_patterns

# Repository and branch validation
validate_repository_access() {
  local repo="${BUILDKITE_REPO:-}"
  local branch="${BUILDKITE_BRANCH:-}"
  local allowed_branches="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_CONDITIONS_BRANCHES:-[]}"
  
  # Skip validation if no branch restrictions
  if [[ "${allowed_branches}" == "[]" ]]; then
    echo "‚úÖ No branch restrictions configured"
    return 0
  fi
  
  # Check if current branch is allowed
  python3 -c "
import json
import sys

allowed = json.loads('${allowed_branches}')
current_branch = '${branch}'

if not allowed or current_branch in allowed:
    print(f'‚úÖ Branch \"{current_branch}\" is allowed for AI analysis')
else:
    print(f'‚ÑπÔ∏è Branch \"{current_branch}\" not in allowed list: {allowed}')
    print('Skipping AI error analysis for this branch')
    # Set flag to skip analysis but don't fail the build
    sys.exit(42)  # Special exit code to indicate skip
"
  
  local exit_code=$?
  if [[ $exit_code -eq 42 ]]; then
    export AI_ERROR_ANALYSIS_SKIP="true"
    return 0
  elif [[ $exit_code -ne 0 ]]; then
    echo "‚ùå Repository validation failed"
    return 1
  fi
}

validate_repository_access

# Set up caching if enabled
setup_caching() {
  local cache_enabled="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_PERFORMANCE_CACHE_ENABLED:-true}"
  local cache_dir="${BUILDKITE_BUILD_PATH}/.ai-error-analysis-cache"
  
  if [[ "${cache_enabled}" == "true" ]]; then
    mkdir -p "${cache_dir}"
    export AI_ERROR_ANALYSIS_CACHE_DIR="${cache_dir}"
    echo "‚úÖ Caching enabled at ${cache_dir}"
  else
    echo "‚ÑπÔ∏è Caching disabled"
  fi
}

setup_caching

# Install Python dependencies if needed
install_dependencies() {
  local lib_dir="${PLUGIN_DIR}/lib"
  
  # Check if requests library is available
  if ! python3 -c "import requests" 2>/dev/null; then
    echo "üì¶ Installing required Python packages..."
    python3 -m pip install --user requests || {
      echo "‚ùå Failed to install Python dependencies"
      echo "Please ensure 'requests' library is available: pip install requests"
      exit 1
    }
  fi
  
  echo "‚úÖ Python dependencies satisfied"
}

install_dependencies

# Set up signal handlers for cleanup
setup_signal_handlers() {
  # Create cleanup function
  cleanup() {
    local exit_code=$?
    echo "--- ${LOG_PREFIX} Cleaning up environment setup"
    
    # Remove any temporary files created during setup
    if [[ -n "${AI_ERROR_ANALYSIS_TEMP_DIR:-}" ]] && [[ -d "${AI_ERROR_ANALYSIS_TEMP_DIR}" ]]; then
      rm -rf "${AI_ERROR_ANALYSIS_TEMP_DIR}"
    fi
    
    exit $exit_code
  }
  
  # Register cleanup on script exit
  trap cleanup EXIT
}

setup_signal_handlers

# Debug information (if debug mode enabled)
DEBUG_MODE="${BUILDKITE_PLUGIN_AI_ERROR_ANALYSIS_ADVANCED_DEBUG_MODE:-false}"
if [[ "${DEBUG_MODE}" == "true" ]]; then
  echo "--- ${LOG_PREFIX} Debug Information"
  echo "Plugin directory: ${PLUGIN_DIR}"
  echo "Python version: $(python3 --version)"
  echo "Current user: $(whoami)"
  echo "Working directory: $(pwd)"
  echo "Available disk space: $(df -h . | tail -1 | awk '{print $4}')"
  echo "Memory usage: $(free -h | grep '^Mem:' | awk '{print $3 "/" $2}' || echo 'N/A')"
  
  # Show relevant environment variables (redacted)
  echo "Environment variables:"
  env | grep -E "^(BUILDKITE_|AI_ERROR_ANALYSIS_)" | sed 's/\(.*=\).*/\1[REDACTED]/' | sort
fi

# Export configuration for other hooks
export AI_ERROR_ANALYSIS_INITIALIZED="true"
export AI_ERROR_ANALYSIS_LOG_PREFIX="${LOG_PREFIX}"

echo "‚úÖ ${LOG_PREFIX} Environment setup complete"

# Health check
echo "--- ${LOG_PREFIX} Running health check"
if python3 "${PLUGIN_DIR}/lib/health_check.py"; then
  echo "‚úÖ Health check passed"
else
  echo "‚ùå Health check failed"
  exit 1
fi